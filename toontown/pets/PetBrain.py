"""PetBrain module: contains the PetBrain class"""

from pandac.PandaModules import *
from otp.otpbase.PythonUtil import weightedChoice, randFloat, Functor
from otp.otpbase.PythonUtil import list2dict
from direct.showbase import DirectObject
from direct.distributed import DistributedObjectAI
from direct.directnotify import DirectNotifyGlobal
from direct.task import Task
from direct.fsm import FSM
from toontown.toon import DistributedToonAI
from toontown.pets import PetConstants, PetObserve, PetGoal, PetGoalMgr
from toontown.pets import PetTricks, PetLookerAI
import random, types
from libtoontown import *

class PetBrain(DirectObject.DirectObject, CPetBrain):
    """This class handles the thought processes of Pets. It collects
    observations of the pet's environment, and controls the pet based
    on those observations.
    """
    notify = DirectNotifyGlobal.directNotify.newCategory("PetBrain")
    #notify.setDebug(True)

    def __init__(self, pet):
        CPetBrain.__init__(self)
        self.pet = pet
        self.focus = None
        self.started = 0
        self.inMovie = 0
        self.chaseNode = self.pet.getRender().attachNewNode('PetChaseNode')
        # create our goal manager
        self.goalMgr = PetGoalMgr.PetGoalMgr(self.pet)
        # dict of doId to goals related to that doId
        self.doId2goals = {}
        # dict of nearby avatars
        self.nearbyAvs = {}
        # dict of doId:None of avatars that we are aware of and have goals for
        self.avAwareness = {}
        # dict of toon avIds we are aware of to timestamp of last interaction.
        # This is here to let the pet know that he shouldn't run away when
        # a Toon is doing things with him.
        self.lastInteractTime = {}
        # work through nearby avs linearly rather than call random.choice,
        # for speed
        self.nextAwarenessIndex = 0
        if __dev__:
            self.pscPrior = PStatCollector('App:Show code:petThink:UpdatePriorities')
            self.pscAware = PStatCollector('App:Show code:petThink:ShuffleAwareness')
            self.pscResc = PStatCollector('App:Show code:petThink:Reschedule')

    def destroy(self):
        taskMgr.remove(self.getTeleportTaskName())
        if __dev__:
            del self.pscPrior
            del self.pscAware
            del self.pscResc
        self.stop()
        self.goalMgr.destroy()
        self.chaseNode.removeNode()
        del self.chaseNode
        del self.focus
        del self.pet
        if self.doId2goals:
            self.notify.warning("destroy(): self.doId2goals is not empty: %s" % list(self.doId2goals.keys()))
            for goalList in list(self.doId2goals.values()):
                for goal in goalList:
                    goal.destroy()
        del self.doId2goals
        del self.avAwareness

    def getThinkTaskName(self):
        return 'petThink-%s' % self.pet.doId

    def getTeleportTaskName(self):
        return 'petTeleport-%s' % self.pet.doId

    # these events are generated by the brain as it observes things
    # TODO: genericize this; brain.getObserveActionEvent(ATTEND_START, av.doId)
    def getObserveEventAttendedByAvStart(self, otherDoId):
        # generated when we detect that a particular avatar is looking at us
        # pass in doId of avatar
        return 'petObserveAttendedByAvStart-%s-%s' % (self.pet.doId, otherDoId)
    def getObserveEventAttendedByAvStop(self, otherDoId):
        # generated when we detect that a particular avatar is no longer
        # looking at us
        # pass in doId of avatar
        return 'petObserveAttendedByAvStop-%s-%s' % (self.pet.doId, otherDoId)
    def getObserveEventAttendingAvStart(self, otherDoId):
        # generated when we detect that we are looking at a particular avatar
        # pass in doId of avatar
        return 'petObserveAttendingAvStart-%s-%s' % (self.pet.doId, otherDoId)
    def getObserveEventAttendingAvStop(self, otherDoId):
        # generated when we detect that we are no longer looking at a
        # particular avatar
        # pass in doId of avatar
        return 'petObserveAttendingAvStop-%s-%s' % (self.pet.doId, otherDoId)

    def start(self):
        PetBrain.notify.debug('start: %s' % self.pet.doId)
        # who's looking at us
        self.lookers = {}
        # who we're looking at
        self.lookees = {}
        #self.attentionLeft = 0.
        self.accept(PetLookerAI.getStartLookedAtByOtherEvent(self.pet.doId),
                    self._handleLookedAtByOtherStart)
        self.accept(PetLookerAI.getStopLookedAtByOtherEvent(self.pet.doId),
                    self._handleLookedAtByOtherStop)
        self.accept(PetLookerAI.getStartLookingAtOtherEvent(self.pet.doId),
                    self._handleLookingAtOtherStart)
        self.accept(PetLookerAI.getStopLookingAtOtherEvent(self.pet.doId),
                    self._handleLookingAtOtherStop)

        # add global goals
        self.globalGoals = [
            PetGoal.Wander(),
            ]
        for goal in self.globalGoals:
            self.goalMgr.addGoal(goal)

        for doId in self.pet._getNearbyAvatarDict():
            self._handleAvatarArrive(doId)

        self.tLastLonelinessUpdate = globalClock.getFrameTime()

        # start thinking
        taskMgr.doMethodLater(
            simbase.petThinkPeriod * random.random(),
            self._think, self.getThinkTaskName())
        self.started = 1

    def stop(self):
        PetBrain.notify.debug('stop: %s' % self.pet.doId)
        if not self.started:
            return
        self.started = 0
        del self.lookers
        del self.lookees

        # remove goals
        for doId in self.pet._getNearbyAvatarDict():
            self._handleAvatarLeave(doId)
        for goal in self.globalGoals:
            self.goalMgr.removeGoal(goal)
            goal.destroy()
        del self.globalGoals

        self.clearFocus()
        taskMgr.remove(self.getThinkTaskName())
        self.ignore(PetLookerAI.getStartLookedAtByOtherEvent(self.pet.doId))
        self.ignore(PetLookerAI.getStopLookedAtByOtherEvent(self.pet.doId))
        self.ignore(PetLookerAI.getStartLookingAtOtherEvent(self.pet.doId))
        self.ignore(PetLookerAI.getStopLookingAtOtherEvent(self.pet.doId))

    # make the pet observe something
    def observe(self, petObserve):
        # randomly drop some on the floor
        if petObserve.isForgettable():
            if random.random() < (.05 * self.pet.traits.forgetfulness):
                return
        petObserve._influence(self)

    def updateLastInteractTime(self, avId):
        # call this when an avatar does something that should cause the
        # pet to stick around for a while
        if avId in self.lastInteractTime:
            self.lastInteractTime[avId] = globalClock.getFrameTime()

    def _think(self, task=None):
        if not self.inMovie:
            # called every once in a while to allow the pet to do high-level
            # 'thinking', i.e. 'what do I want to do'?
            if __dev__:
                self.pscPrior.start()
            self._updatePriorities()
            if __dev__:
                self.pscPrior.stop()

            """
            self.attentionLeft -= simbase.petThinkPeriod

            if self.attentionLeft <= 0.:
                self._chooseNewGoal()
                """

            if __dev__:
                self.pscAware.start()
            # pick a random avatar and consider becoming aware of them;
            # shake things up
            if len(self.nearbyAvs) > PetConstants.MaxAvatarAwareness:
                self.nextAwarenessIndex %= len(self.nearbyAvs)
                self._considerBecomeAwareOf(
                    list(self.nearbyAvs.keys())[self.nextAwarenessIndex])
                self.nextAwarenessIndex += 1
            if __dev__:
                self.pscAware.stop()

            # don't update the pet's loneliness every time through
            curT = globalClock.getFrameTime()
            tSinceLastLonelinessUpdate = curT - self.tLastLonelinessUpdate
            if (tSinceLastLonelinessUpdate >=
                PetConstants.LonelinessUpdatePeriod):
                self.tLastLonelinessUpdate = curT
                numLookers = len(self.lookers)
                if numLookers:
                    dt = tSinceLastLonelinessUpdate
                    self.pet.lerpMood('loneliness',
                                      max(-1., dt * -.003 * numLookers))
                    if numLookers > 5:
                        self.pet.lerpMood('excitement',
                                          min(1., dt * .001 * numLookers))

        if __dev__:
            self.pscResc.start()
        # schedule the next think
        taskMgr.doMethodLater(simbase.petThinkPeriod, self._think,
                              self.getThinkTaskName())
        if __dev__:
            self.pscResc.stop()
        return Task.done

    def _updatePriorities(self):
        # TODO: create and update values that the goals will reference,
        # such as 'how much do I like a particular toon right now'
        
        # tell the goal manager to re-evaluate its priorities
        self.goalMgr.updatePriorities()

    # make brain observe that we are looking at someone
    def _handleLookingAtOtherStart(self, avId):
        """assert(avId not in self.lookees), (
            '%s: already looking at av %s' % (self.pet.doId, avId))"""
        if avId in self.lookees:
            PetBrain.notify.warning(
                '%s: already looking at av %s' % (self.pet.doId, avId))
            return
        self.lookees[avId] = avId
        self.observe(PetObserve.PetActionObserve(
            PetObserve.Actions.ATTENDING_START, avId))
    def _handleLookingAtOtherStop(self, avId):
        """assert(avId in self.lookees), (
            '%s: not looking at av %s' % (self.pet.doId, avId))"""
        if avId not in self.lookees:
            PetBrain.notify.warning(
                '%s: not looking at av %s' % (self.pet.doId, avId))
            return
        del self.lookees[avId]
        self.observe(PetObserve.PetActionObserve(
            PetObserve.Actions.ATTENDING_STOP, avId))

    # update table of who's looking at us, and make brain observe the fact
    def _handleLookedAtByOtherStart(self, avId):
        """assert(avId not in self.lookers), (
            '%s: av %s already looking at me' % (self.pet.doId, avId))"""
        if avId in self.lookers:
            PetBrain.notify.warning(
                '%s: av %s already looking at me' % (self.pet.doId, avId))
            return
        self.lookers[avId] = avId
        self.observe(PetObserve.PetActionObserve(
            PetObserve.Actions.ATTENDED_START, avId))
    def _handleLookedAtByOtherStop(self, avId):
        """assert(avId in self.lookers), (
            '%s: av %s not looking at me' % (self.pet.doId, avId))"""
        if avId not in self.lookers:
            PetBrain.notify.warning(
                '%s: av %s not looking at me' % (self.pet.doId, avId))
            return
        del self.lookers[avId]
        self.observe(PetObserve.PetActionObserve(
            PetObserve.Actions.ATTENDED_STOP, avId))

    # call these to find out about who's looking at who
    def lookedAtBy(self, avId):
        """assert type(avId) == types.IntType, (
            'invalid avId: %s' % avId)"""
        # returns true if avatar is looking at us
        return avId in self.lookers
    def lookingAt(self, avId):
        """assert type(avId) == types.IntType, (
            'invalid avId: %s' % avId)"""
        # returns true if we are looking at avatar
        return avId in self.lookees

    def getAvIdsLookingAtUs(self):
        return self.lookers
    def getAvIdsWeAreLookingAt(self):
        return self.lookees

    """
    # influence the pet's attention duration for his current focus
    def setAttentionLeft(self, seconds):
        # set the pet's remaining attention
        self.attentionLeft = seconds
    def addAttention(self, seconds):
        # add seconds to the pet's remaining attention
        self.attentionLeft += seconds
        """

    def setFocus(self, object):
        # assign a new object as our focus of attention
        # you should call this if we are doing an action that should be
        # interrupted if an avatar (our focus) leaves/logs out
        if isinstance(self.focus, DistributedObjectAI.DistributedObjectAI):
            self.ignore(self.focus.getDeleteEvent())
            # also add them to the lastInteractTime record
            self.lastInteractTime.setdefault(self.focus.doId, 0)

        PetBrain.notify.debug('setFocus: %s' % object)

        self.focus = object
        if isinstance(self.focus, DistributedObjectAI.DistributedObjectAI):
            self.accept(self.focus.getDeleteEvent(),
                        self._handleFocusHasLeft)

    def getFocus(self):
        return self.focus
    def clearFocus(self):
        self.setFocus(None)

    def _handleFocusHasLeft(self):
        # called when the avatar we are focusing on is about to leave
        # they're still actually here while we're in this function
        
        # we need to transition away from chasing the avatar to prevent
        # a crash; inspect the avatar's last position instead
        if self.focus.isEmpty():
            # focus avatar has already left the scenegraph
            self.chaseNode.setPos(self.pet, 0,0,0)
        else:
            self.chaseNode.setPos(self.focus, 0,0,0)
        self._inspectSpot(self.chaseNode)

    # behaviors
    # TODO: should the pet set the brain's focus when it enters one of
    # these FSM states?
    # use one of these instead of directly calling self.pet.actionFSM.request
    # returns non-zero if goal is successfully started
    # you may pass in a function instead of an avatar for most of these
    def _chase(self, target):
        if callable(target):
            target = target()
        if target is None:
            return 0
        self.setFocus(target)
        self.pet.actionFSM.request('Chase', target)
        #self.setAttentionLeft(randFloat(10.,20.))
        return 1

    def _wander(self):
        self.clearFocus()
        self.pet.actionFSM.request('Wander')
        #self.setAttentionLeft(randFloat(10.,30.))
        return 1

    def _unstick(self):
        self.clearFocus()
        self.pet.actionFSM.request('Unstick')
        return 1

    def _flee(self, chaser):
        if callable(chaser):
            chaser = chaser()
        if chaser is None:
            return 0
        self.setFocus(chaser)
        self.pet.actionFSM.request('Flee', chaser)
        #self.setAttentionLeft(randFloat(8.,15.))
        return 1

    def _inspectSpot(self, spot=None):
        if spot is None:
            spot = NodePath('randomSpot')
            spot.setPos(randFloat(-20,20),
                        randFloat(-20,20),
                        0)
        self.setFocus(spot)
        self.pet.actionFSM.request('InspectSpot', spot)
        #self.setAttentionLeft(randFloat(5.,10.))
        return 1

    def _stay(self, avatar):
        self.setFocus(avatar)
        self.pet.actionFSM.request('Stay', avatar)
        #self.setAttentionLeft(randFloat(3*60, 5*60))
        return 1

    def _doTrick(self, trickId, avatar):
        self.setFocus(avatar)
        self.pet.actionFSM.request('Trick', avatar, trickId)
        return 1

    def _heal(self, avatar):
        if callable(avatar):
            avatar = avatar()
        if avatar is None:
            return 0
        self.setFocus(avatar)
        self.pet.actionFSM.request('Heal', avatar)
        return 1

    def _startMovie(self):
        # keep the pet from doing anything while the movie is playing
        self.setFocus(None)
        self.pet.actionFSM.request('Movie')
        self.inMovie = 1

    def _endMovie(self):
        self.inMovie = 0

    # these handlers handle the influence of various types of PetObserves
    def _handleGenericObserve(self, observe):
        pass

    def _handleActionObserve(self, observe):
        action = observe.getAction()
        avId = observe.getAvId()

        OA = PetObserve.Actions
        dbg = PetBrain.notify.debug
        if action == OA.ATTENDED_START:
            dbg('avatar %s is looking at me' % avId)
            self.pet.lerpMoods({
                'boredom': -.1,
                'excitement': .05,
                'loneliness': -.05,
                })
            messenger.send(self.getObserveEventAttendedByAvStart(avId))
        elif action == OA.ATTENDED_STOP:
            dbg('avatar %s is no longer looking at me' % avId)
            messenger.send(self.getObserveEventAttendedByAvStop(avId))

        elif action == OA.ATTENDING_START:
            dbg('I am looking at avatar %s' % avId)
            messenger.send(self.getObserveEventAttendingAvStart(avId))
        elif action == OA.ATTENDING_STOP:
            dbg('I am no longer looking at avatar %s' % avId)
            messenger.send(self.getObserveEventAttendingAvStop(avId))

        elif action == OA.CHANGE_ZONE:
            if avId != self.pet.doId:
                oldZoneId, newZoneId = observe.getData()

                PetBrain.notify.debug(
                    '%s.CHANGE_ZONE: %s, %s->%s' % (self.pet.doId, avId,
                                                    oldZoneId, newZoneId))

                myZoneId = self.pet.zoneId
                if newZoneId != oldZoneId:
                    if newZoneId == myZoneId:
                        self._handleAvatarArrive(avId)
                    elif oldZoneId == myZoneId:
                        self._handleAvatarLeave(avId)

                if self.pet.inEstate:
                    # is it the estate owner or our owner?
                    if avId in (self.pet.ownerId, self.pet.estateOwnerId):
                        # are they leaving the estate that we're in?
                        if ((oldZoneId in self.pet.estateZones) and
                            (newZoneId not in self.pet.estateZones)):
                            if avId == self.pet.ownerId:
                                # owner is leaving the estate
                                self._handleOwnerLeave()
                            else:
                                # estate owner is leaving
                                self._handleEstateOwnerLeave()

        elif action == OA.LOGOUT:
            if avId == self.pet.ownerId:
                self._handleOwnerLeave()
            elif avId == self.pet.estateOwnerId:
                self._handleEstateOwnerLeave()

        elif action == OA.FEED:
            dbg('avatar %s is feeding me' % avId)
            self.pet.lerpMoods({
                'affection': .35,
                'anger': -.07,
                'boredom': -.5,
                'excitement': .5,
                'fatigue': -.2,
                'hunger': -.5,
                'loneliness': -.08,
                'playfulness': .1,
                'restlessness': -.05,
                'sadness': -.2,
                })
            self.updateLastInteractTime(avId)
            avatar = simbase.air.doId2do.get(avId)
            if avatar is not None:
                avatar.setHatePets(0)
        
        elif action == OA.SCRATCH:
            dbg('avatar %s is scratching me' % avId)
            self.pet.lerpMoods({
                'affection': .45,
                'anger': -.1,
                'boredom': -.8,
                'excitement': .5,
                'fatigue': -.25,
                'loneliness': -.2,
                'playfulness': .1,
                'restlessness': -.2,
                'sadness': -.2,
                })
            self.updateLastInteractTime(avId)
            avatar = simbase.air.doId2do.get(avId)
            if avatar is not None:
                avatar.setHatePets(0)
            
        elif action == OA.GARDEN:
            dbg('avatar %s is gardening' % avId)
            avatar = simbase.air.doId2do.get(avId)
            if avatar is not None:
               if self.getFocus() == avatar:
                  self._wander()
            #self.updateLastInteractTime(avId)

    def _handlePhraseObserve(self, observe):
        def _handleGettingFriendlyAttention(avId, self=self):
            self.pet.lerpMoods({
                'boredom': -.85,
                'restlessness': -.1,
                'playfulness': .2,
                'loneliness': -.4,
                'sadness': -.1,
                'fatigue': -.05,
                'excitement': .05,
                'anger': -.05,
                })
            self.updateLastInteractTime(avId)

        def _handleComeHere(avId, self=self):
            # this avatar is calling us
            avatar = simbase.air.doId2do.get(avId)
            if avatar:
                self._chase(avatar)
                avatar.setHatePets(0)

        def _handleFollowMe(avId, self=self):
            # this avatar is calling us
            avatar = simbase.air.doId2do.get(avId)
            if avatar:
                self._chase(avatar)
                avatar.setHatePets(0)

        def _handleStay(avId, self=self):
            # this avatar is telling us to stay
            avatar = simbase.air.doId2do.get(avId)
            if avatar:
                self._stay(avatar)

        def _handleCriticism(avId, self=self):
            # avatar is criticizing us
            ownerFactor = .5
            if avId == self.pet.ownerId:
                ownerFactor = 1.
            self.pet.lerpMoods({
                'affection': -.4,
                'anger': .4,
                'boredom': -.3,
                'confusion': .05,
                'fatigue': .2,
                'playfulness': -.1,
                'sadness': .5 * ownerFactor,
                })

        def _handleGoAway(avId, self=self):
            # av is telling us to go away
            avatar = simbase.air.doId2do.get(avId)
            if avatar is not None:
                if self.getFocus() == avatar:
                    self._wander()

        def _handleDoTrick(trickId, avId, self=self):
            # av is telling us to do a trick
            avatar = simbase.air.doId2do.get(avId)
            if avatar:
                if self.lookedAtBy(avatar.doId):
                    # there should only be one DoTrick goal at a time
                    if not self.goalMgr.hasTrickGoal():
                        # will the pet do the trick?
                        if not self.pet._willDoTrick(trickId):
                            self.pet.trickFailLogger.addEvent(trickId)
                            trickId = PetTricks.Tricks.BALK
                        # add a goal of doing the trick
                        trickGoal = PetGoal.DoTrick(avatar, trickId)
                        self.goalMgr.addGoal(trickGoal)

        phrase = observe.getPetPhrase()
        avId = observe.getAvId()

        OP = PetObserve.Phrases
        # is the avatar attending to us?
        if phrase in list2dict([
            OP.COME,
            OP.FOLLOW_ME,
            OP.STAY,
            OP.NEED_LAFF,
            OP.NEED_GAGS,
            OP.NEED_JB,
            OP.HI,
            OP.SOOTHE,
            OP.PRAISE,
            OP.HAPPY,
            OP.QUESTION,
            OP.FRIENDLY,
            OP.LETS_PLAY,
            OP.DO_TRICK,
            ]):
            _handleGettingFriendlyAttention(avId)

        # calling us over?
        if phrase == OP.COME:
            _handleComeHere(avId)
        # telling us to follow them?
        if phrase == OP.FOLLOW_ME:
            _handleFollowMe(avId)
        # telling us to stay?
        if phrase == OP.STAY:
            _handleStay(avId)
        # criticizing us?
        if phrase == OP.CRITICISM:
            _handleCriticism(avId)
        # dismissing us?
        if phrase == OP.GO_AWAY:
            _handleGoAway(avId)
        # telling us to do a trick?
        if phrase == OP.DO_TRICK:
            _handleDoTrick(observe.getTrickId(), avId)

    # funcs to add and remove goals specific to a particular av
    def _addGoalsReAvatar(self, avId):
        # add goals that have to do with a particular avatar
        av = self.pet.air.doId2do.get(avId)
        """assert av is not None, (
            '%s._addGoalsReAvatar: %s not in doId2do' % (self.pet.doId, avId))
            """
        if av is None:
            PetBrain.notify.warning(
                '%s._addGoalsReAvatar: %s not in doId2do' % (self.pet.doId,
                                                             avId))
            return

        # add goals related to this avatar
        if avId not in self.doId2goals:
            goals = [PetGoal.ChaseAvatar(av),
                     PetGoal.FleeFromAvatar(av),
                     ]
            """
            if isinstance(av, DistributedToonAI.DistributedToonAI):
                goals += [
                    ]
                    """
            self.doId2goals[avId] = goals
            self.lastInteractTime.setdefault(avId, 0)

        for goal in self.doId2goals[avId]:
            self.goalMgr.addGoal(goal)

    def _removeGoalsReAvatar(self, avId):
        # remove goals relating to a particular avatar, if any
        if not avId in self.doId2goals:
            PetBrain.notify.warning(
                'no goals re av %s to remove' % avId)
            return
        for goal in self.doId2goals[avId]:
            self.goalMgr.removeGoal(goal)
            goal.destroy()
        del self.doId2goals[avId]

    # funcs to add and remove avatars from our awareness.
    # This reduces the number of goals we have to deal with at once
    def _considerBecomeAwareOf(self, avId):
        av = simbase.air.doId2do.get(avId)
        if av is None:
            PetBrain.notify.warning('_considerBecomeAwareOf: av %s does not exist' % avId)
            return
        
        if avId in self.avAwareness:
            return
        def becomeAwareOf(avId, self=self):
            self.avAwareness[avId] = None
            self._addGoalsReAvatar(avId)

        # if our awareness isn't maxed, add this av
        if len(self.avAwareness) < PetConstants.MaxAvatarAwareness:
            becomeAwareOf(avId)
            return

        def calcInterest(avId, self=self):
            # our owner should pretty much always be in our awareness
            if avId == self.pet.ownerId:
                return 100.
            # TODO: do something more clever?
            return random.random()
        # figure out who we have the lowest interest in
        avInterest = calcInterest(avId)
        minInterest = avInterest
        minInterestAvId = avId
        for awAvId in self.avAwareness:
            i = calcInterest(awAvId)
            if i < minInterest:
                minInterest = i
                minInterestAvId = awAvId
                # for speed: stop as soon as we find someone lower
                break
        if minInterestAvId != avId:
            # this new av is more interesting than some other av
            self._removeAwarenessOf(minInterestAvId)
            becomeAwareOf(avId)

    def _removeAwarenessOf(self, avId):
        if avId in self.avAwareness:
            # get rid of goals for this av
            self._removeGoalsReAvatar(avId)
            del self.avAwareness[avId]

    # funcs to handle arrival and removal of avatars
    def _handleAvatarArrive(self, avId):
        # TODO: should we ever not do this?
        # TODO: longer time since last seen -> more excitement
        PetBrain.notify.debug('%s._handleAvatarArrive: %s' % (
            self.pet.doId, avId))
        """assert avId not in self.nearbyAvs"""
        if avId in self.nearbyAvs:
            PetBrain.notify.warning(
                '%s already in self.nearbyAvs' % avId)
            return
        self.nearbyAvs[avId] = None
        excitement = .3
        if avId == self.pet.ownerId:
            excitement = .7
        self.pet.lerpMoods({
            'excitement': .7,
            'loneliness': -.4,
            })
        self._considerBecomeAwareOf(avId)

    def _handleAvatarLeave(self, avId):
        PetBrain.notify.debug('%s._handleAvatarLeave: %s' % (
            self.pet.doId, avId))
        # Note: if a toon has left the zone, but has not yet sent out his
        # "I've left" ActionObserve, and a pet comes into the zone, the
        # pet will not be aware of that toon. When the ActionObserve does
        # arrive, this function is called.
        # Therefore it's OK that the Toon is not in this list. Just print
        # a warning.
        #assert avId in self.nearbyAvs
        if avId not in self.nearbyAvs:
            PetBrain.notify.warning('av %s not in self.nearbyAvs' % avId)
            return
        del self.nearbyAvs[avId]
        self.pet.lerpMoods({
            'loneliness': .1,
            })
        self._removeAwarenessOf(avId)

    def _handleOwnerLeave(self):
        # TODO: make this happen sometime in the future
        self.pet.teleportOut()
        taskMgr.doMethodLater(PetConstants.TELEPORT_OUT_DURATION,
                              self.pet.requestDelete,
                              self.getTeleportTaskName()
                              )
        
    def _handleEstateOwnerLeave(self):
        # TODO: make this happen sometime in the future
        self.pet.teleportOut()
        taskMgr.doMethodLater(PetConstants.TELEPORT_OUT_DURATION,
                              self.pet.requestDelete,
                              self.getTeleportTaskName()
                              )
