import math
from pandac.PandaModules import Point3, CollisionSphere, CollisionNode, \
     CollisionHandlerEvent, TextNode, VBase4, SmoothMover, NodePath, BitMask32
from direct.fsm import FSM
from direct.distributed import DistributedObject
from direct.distributed.ClockDelta import globalClockDelta
from direct.directnotify import DirectNotifyGlobal
from direct.gui.DirectGui import DGG, DirectButton, DirectLabel, DirectWaitBar
from direct.interval.IntervalGlobal import Sequence, Wait, ActorInterval, \
     Parallel, Func, LerpPosInterval, LerpHprInterval, ProjectileInterval, \
     LerpScaleInterval, SoundInterval
from otp.otpbase import PythonUtil
from direct.task import Task
from toontown.golf import GolfGlobals
from toontown.toonbase import ToontownGlobals
from toontown.toonbase import TTLocalizer

class DistributedGolfSpot(DistributedObject.DistributedObject, FSM.FSM):
    """ This is one of four golf spots to appear in the corner of the CEO banquet
    room.  """    

    notify = DirectNotifyGlobal.directNotify.newCategory('DistributedGolfSpot')
    positions =((-45, 100, GolfGlobals.GOLF_BALL_RADIUS  ),
                (-15, 100, GolfGlobals.GOLF_BALL_RADIUS ),
                (15, 100, GolfGlobals.GOLF_BALL_RADIUS  ),
                (45, 100, GolfGlobals.GOLF_BALL_RADIUS  ))
    toonGolfOffsetPos  = Point3(-2,0, -GolfGlobals.GOLF_BALL_RADIUS)
    toonGolfOffsetHpr = Point3(-90,0,0)
    rotateSpeed = 20    # degrees per second

    # The number of seconds it takes to move the power meter to
    # full the first time.
    golfPowerSpeed = base.config.GetDouble('golf-power-speed', 3)

    # The exponent that controls the factor at which the power
    # meter slows down over time.  Values closer to 1.0 slow down less
    # quickly.
    golfPowerExponent = base.config.GetDouble('golf-power-exponent', 0.75)

    def __init__(self, cr):
        DistributedObject.DistributedObject.__init__(self, cr)
        FSM.FSM.__init__(self, 'DistributedGolfSpot')
        self.boss = None
        self.index = 0
        self.avId = 0
        self.toon = None # the actual toon which should match up with self.avId
        self.golfSpotSmoother = SmoothMover()
        self.golfSpotSmoother.setSmoothMode(SmoothMover.SMOn)
        self.smoothStarted = 0
        self.__broadcastPeriod = 0.2     
        if self.index > len(self.positions):
            self.notify.error("Invalid index %d" % index)
        self.fadeTrack = None
        
        # stuff related to power bar
        self.setupPowerBar()
        self.aimStart = None

        self.golfSpotAdviceLabel = None  

        # This number increments each time we change direction on the
        # crane controls.  It's used to update the animation
        # appropriately.
        self.changeSeq = 0
        self.lastChangeSeq = 0
              
        self.controlKeyAllowed = False
        self.flyBallTracks = {}
        self.splatTracks = {}
        self.__flyBallBubble = None
        self.flyBallHandler = None
        self.__flyBallSequenceNum = 0
        self.swingInterval = None
        self.lastHitSequenceNum = -1
        self.goingToReward = False
        self.gotHitByBoss = False

        self.releaseTrack = None
        self.grabTrack = None
        self.restoreScaleTrack = None

    def setBossCogId(self, bossCogId):
        """Handle receiving the CEO doId from the server."""
        self.bossCogId = bossCogId

        # This would be risky if we had toons entering the zone during
        # a battle--but since all the toons are always there from the
        # beginning, we can be confident that the BossCog has already
        # been generated by the time we receive the generate for its
        # associated battles.
        self.boss = base.cr.doId2do[bossCogId]
        self.boss.setGolfSpot(self, self.index)

    def setIndex(self, index):
        """Handle receiving the index which identifies our side the server."""
        self.index = index
        # WARNING debug only, remove this
        #if (index == 0):
        #    base.gs = self

    def disable(self):
        """Disable ourself."""
        DistributedObject.DistributedObject.disable(self)
        self.ignoreAll()

    def delete(self):
        """Delete ourself."""

        DistributedObject.DistributedObject.delete(self)
        self.ignoreAll()

        self.boss = None

    def announceGenerate(self):
        """Do more setup once all required fields are in."""
        DistributedObject.DistributedObject.announceGenerate(self)
        self.triggerName = self.uniqueName('trigger')
        self.triggerEvent = 'enter%s' % (self.triggerName)
        self.smoothName = self.uniqueName('golfSpotSmooth')
        self.golfSpotAdviceName = self.uniqueName('golfSpotAdvice')
        self.posHprBroadcastName = self.uniqueName('golfSpotBroadcast')
        self.ballPowerTaskName = self.uniqueName('updateGolfPower')
        self.adjustClubTaskName = self.uniqueName('adjustClub')
        self.loadAssets()
        self.accept('flyBallHit-%d' % self.index, self.__flyBallHit)

    def loadAssets(self):
        """Load our assets."""
        self.root = render.attachNewNode('golfSpot-%d'% self.index)
        self.root.setPos(* self.positions[self.index])        
        self.ballModel = loader.loadModel('phase_6/models/golf/golf_ball')
        self.ballColor = VBase4(1,1,1,1)
        if self.index < len( GolfGlobals.PlayerColors):
            self.ballColor = VBase4( * GolfGlobals.PlayerColors[self.index])
            self.ballModel.setColorScale(self.ballColor )
        self.ballModel.reparentTo(self.root)
        self.club = loader.loadModel('phase_6/models/golf/putter')
        self.clubLookatSpot = self.root.attachNewNode('clubLookat')
        self.clubLookatSpot.setY(- (GolfGlobals.GOLF_BALL_RADIUS + 0.1))
        
        # create a collision sphere to trigger when we touch the ball
        
        # Make a trigger sphere so we can detect when the local avatar
        # runs up to the controls.  We bury the sphere mostly under
        # the floor to minimize accidental collisions.
        cs = CollisionSphere(0, 0, 0, 1)
        cs.setTangible(0)
        cn = CollisionNode(self.triggerName)
        cn.addSolid(cs)
        cn.setIntoCollideMask(ToontownGlobals.WallBitmask)
        self.trigger = self.root.attachNewNode(cn)
        self.trigger.stash()

        self.hitBallSfx = loader.loadSfx('phase_6/audio/sfx/Golf_Hit_Ball.ogg')

    def cleanup(self):        
        if self.swingInterval:
            self.swingInterval.finish()
            self.swingInterval = None
        if self.releaseTrack:
            self.releaseTrack.finish()
            self.releaseTrack = None
        flyTracks = list(self.flyBallTracks.values())
        for track in flyTracks:
            track.finish()

        if self.fadeTrack:
            self.fadeTrack.finish()
            self.fadeTrack = None

        if self.restoreScaleTrack:
            self.restoreScaleTrack.finish()
            self.restoreScaleTrack = None
        
        self.root.removeNode()
        self.ballModel.removeNode()
        self.club.removeNode()
        if self.powerBar:
            self.powerBar.destroy()
            self.powerBar = None

        taskMgr.remove(self.triggerName)
        
        assert self.notify.debugStateCall(self)

        self.boss = None
        
    def setState(self, state, avId, extraInfo):
        """Handle the AI telling us the current state, and who controls us."""
        if not self.isDisabled():
            self.gotHitByBoss = extraInfo
            if state == 'C':
                self.demand('Controlled', avId)
            elif state == 'F':
                self.demand('Free')
            elif state == 'O':
                self.demand('Off')
            else:
                self.notify.error("Invalid state from AI: %s" % (state))


    ### FSM States ###

    def enterOff(self):
        """Handle entering the off state."""
        assert self.notify.debugStateCall(self)
        pass

    def exitOff(self):
        """Handle exiting the off state."""
        assert self.notify.debugStateCall(self)
        pass

    def enterFree(self):
        """Handle entering the free state."""
        assert self.notify.debugStateCall(self)
        if self.fadeTrack:
            self.fadeTrack.finish()
            self.fadeTrack = None
            
        # Wait a few seconds before neutralizing the scale; maybe the
        # same avatar wants to come right back (after his 5-second
        # timeout).
        self.restoreScaleTrack = Sequence(Wait(6),
                                          self.getRestoreScaleInterval(),
                                          name = "restoreScaleTrack")
        self.restoreScaleTrack.start()

        if self.avId == localAvatar.doId:
            # Five second timeout on grabbing the same crane again.  Go
            # get a different crane!
            if not self.isDisabled():
                self.ballModel.setAlphaScale(0.3)
                self.ballModel.setTransparency(1)
                taskMgr.doMethodLater(5, self.__allowDetect, self.triggerName)

                self.fadeTrack = Sequence(
                    Func(self.ballModel.setTransparency, 1),
                    self.ballModel.colorScaleInterval(0.2, VBase4(1,1,1,0.3)),
                    name = 'fadeTrack-enterFree')
                self.fadeTrack.start()

        else:
            # Other players can grab this crane immediately.
            self.trigger.unstash()
            self.accept(self.triggerEvent, self.__hitTrigger)

        self.avId = 0

    def exitFree(self):
        """Handle exiting the free state."""
        if self.fadeTrack:
            self.fadeTrack.finish()
            self.fadeTrack = None

        self.restoreScaleTrack.finish() # make sure we don't see a small ball
        self.restoreScaleTrack = None

        taskMgr.remove(self.triggerName)
        #self.ballModel.clearColorScale()
        self.ballModel.clearTransparency()
        
        self.trigger.stash()
        self.ignore(self.triggerEvent)        
        pass

    def enterControlled(self, avId):
        """Handle entering the controlled state."""
        assert self.notify.debugStateCall(self)
        self.avId = avId
        toon = base.cr.doId2do.get(avId)
        if not toon:
            return
        self.enableControlKey()
        self.toon = toon
        self.grabTrack = self.makeToonGrabInterval(toon)

        if avId == localAvatar.doId:
            # The local toon is beginning to control the crane.

            self.boss.toCraneMode()

            camera.reparentTo(self.root)
            camera.setPosHpr(0, -10, 3, 0, 0, 0)
            #self.tube.stash()

            #localAvatar.setPosHpr(self.controls, 0, 0, 0, 0, 0, 0)
            localAvatar.setPos(self.root, self.toonGolfOffsetPos)
            localAvatar.setHpr(self.root, self.toonGolfOffsetHpr)

            localAvatar.sendCurrentPosition()

            #self.__activatePhysics()
            self.__enableControlInterface()
            self.startPosHprBroadcast()
            #self.startShadow()

            # If we get a message from the Place that we exited Crane
            # mode--for instance, because we got hit by flying
            # gears--then ask the AI to yield us up.
            self.accept('exitCrane', self.gotBossZapped)

        else:
            pass
            #self.startSmooth()
            #toon.stopSmooth()
            #self.grabTrack = Sequence(self.grabTrack,
            #                          Func(toon.startSmooth))

        self.grabTrack.start()
        
        pass

    def exitControlled(self):
        """Handle exiting the controlled state."""
        assert self.notify.debugStateCall(self)
        self.grabTrack.finish()
        del self.grabTrack

        if self.swingInterval:
            self.swingInterval.finish()
            self.swingInterval = None

        if not self.ballModel.isEmpty():
            if self.ballModel.isHidden():
                self.notify.debug('ball is hidden scale =%s' % self.ballModel.getScale())            
            else:
                self.notify.debug('ball is showing scale=%s' % self.ballModel.getScale())

        if self.toon and not self.toon.isDisabled():            
            #self.toon.loop('neutral')
            #self.notify.debug('looping neutral')
            self.toon.startSmooth()

        self.releaseTrack = self.makeToonReleaseInterval(self.toon)
        self.stopPosHprBroadcast()
        #self.stopShadow()
        self.stopSmooth()
        if self.avId == localAvatar.doId:
            # The local toon is no longer in control of the crane.

            self.__disableControlInterface()
            #self.__deactivatePhysics()
            #self.tube.unstash()
            if not self.goingToReward:
                camera.reparentTo(base.localAvatar)
                camera.setPos(base.localAvatar.cameraPositions[0][0])
                camera.setHpr(0, 0, 0)


        #self.__straightenCable()
        #self.avId = 0
        #self.toon = None
        self.stopAdjustClubTask()
        self.releaseTrack.start()
        self.enableControlKey()

    def __allowDetect(self, task):
        if self.fadeTrack:
            self.fadeTrack.finish()
        self.fadeTrack = Sequence(
            self.ballModel.colorScaleInterval(0.2, self.ballColor),
            #Func(self.ballModel.clearColorScale),
            Func(self.ballModel.clearTransparency),
            name = 'fadeTrack-allowDetect'
            )
            
        self.fadeTrack.start()

        self.trigger.unstash()
        self.accept(self.triggerEvent, self.__hitTrigger)

    def __hitTrigger(self, event):
        self.d_requestControl()

    def getRestoreScaleInterval(self):
        # This undoes the effect of accomodateToon(), to restore the
        # controls' scale to neutral position.  Unlike
        # accomodateToon(), it has no side effects; you must play (or
        # immediately finish) the interval to restore the scale.
        return Sequence()
        #lerpTime = 1
        #return Parallel(
        #    self.controlModel.scaleInterval(lerpTime, 1, blendType = 'easeInOut'),
        #    self.cc.posInterval(lerpTime, Point3(0, 0, 0), blendType = 'easeInOut'),
        #    self.bottom.posInterval(lerpTime, self.bottomPos, blendType = 'easeInOut'),
        #    self.stickHinge.quatInterval(lerpTime, self.neutralStickHinge, blendType = 'easeInOut'),
        #    )

    def d_requestControl(self):
        self.sendUpdate('requestControl')

    def d_requestFree(self, gotHitByBoss):
        self.sendUpdate('requestFree', [gotHitByBoss])

    def makeToonGrabInterval(self, toon):
        # Generates an interval showing the crane controls scaling to
        # match the toon and the toon simultaneously reaching to grab
        # the controls.  Thenceforth, the toon will animate with the
        # controls.
        origPos = toon.getPos(self.root)
        origHpr = toon.getHpr(self.root)
        a = self.accomodateToon(toon)
        newPos = toon.getPos()
        newHpr = toon.getHpr()
        origHpr.setX(PythonUtil.fitSrcAngle2Dest(origHpr[0], newHpr[0]))
        self.notify.debug('toon.setPosHpr %s %s' % (origPos, origHpr))
        toon.setPosHpr(origPos, origHpr)

        walkTime = 0.2
        reach = Sequence() #ActorInterval(toon, 'GolfPuttLoop')
        if reach.getDuration() < walkTime:
            reach = Sequence(ActorInterval(toon, 'walk', loop = 1,
                                           duration = walkTime - reach.getDuration()),
                             reach)
            
        i = Sequence(
            Parallel(toon.posInterval(walkTime, newPos, origPos),
                     toon.hprInterval(walkTime, newHpr, origHpr),
                     reach),
            #Func(self.startWatchJoystick, toon)
            Func(toon.stopLookAround),            
            )
        if toon == base.localAvatar:
            i.append(Func(self.switchToAnimState, 'GolfPuttLoop'))
        i.append(Func(self.startAdjustClubTask))
        i = Parallel(i, a)

        return i

    def accomodateToon(self,toon):
        # This method has two effects:

        # (1) It computes and returns an interval to scale and slide
        # the crane controls to suit the indicated toon.

        # (2) As a side effect, when it returns, the crane controls are
        # *already* scaled and slid to accomodate the toon, and the toon
        # has been positioned in place to operate the controls.

        # Thus, you can use it either by calling it and playing the
        # interval that it returns to get a smooth lerp, or simply by
        # calling it and ignoring the return value, to jump to
        # position.
        toon.wrtReparentTo(self.root)
        toon.setPos(self.toonGolfOffsetPos)
        toon.setHpr(self.toonGolfOffsetHpr)
        return Sequence()

    def switchToAnimState(self, animStateName, forced = False):
        """Switch the toon to another anim state if not in it already."""
        # temp since we only have anims for male medium torso medium legs
        #dna = base.localAvatar.getStyle()
        #if not( dna.gender == 'm' and (dna.torso =='ms' or dna.torso =='ls')\
        #        and (dna.legs=='m' or dna.legs=='l')):
        #    return
        curAnimState = base.localAvatar.animFSM.getCurrentState()
        #self.notify.debug('curAnimState=%s' % curAnimState)
        curAnimStateName = ''
        if curAnimState:
            curAnimStateName = curAnimState.getName()
        if curAnimStateName != animStateName or forced:
            base.localAvatar.b_setAnimState(animStateName)

    def __enableControlInterface(self):
        """Enable the control interface."""
        gui = loader.loadModel("phase_3.5/models/gui/avatar_panel_gui")

        self.closeButton = DirectButton(
            image = (gui.find("**/CloseBtn_UP"),
                     gui.find("**/CloseBtn_DN"),
                     gui.find("**/CloseBtn_Rllvr"),
                     gui.find("**/CloseBtn_UP"),
                     ),
            relief = None,
            scale = 2,
            text = TTLocalizer.BossbotGolfSpotLeave,
            text_scale = 0.04,
            text_pos = (0, -0.07),
            text_fg = VBase4(1, 1, 1, 1),
            pos = (1.05, 0, -0.82),
            command = self.__exitGolfSpot,
            )
        
        self.accept('escape', self.__exitGolfSpot)

        self.accept('control', self.__controlPressed)
        self.accept('control-up', self.__controlReleased)
        self.accept('InputState-forward', self.__upArrow)
        self.accept('InputState-reverse', self.__downArrow)
        self.accept('InputState-turnLeft', self.__leftArrow)
        self.accept('InputState-turnRight', self.__rightArrow)

        taskMgr.add(self.__watchControls, 'watchGolfSpotControls')

        # In case they don't figure it out, hit them over the head
        # with it after a few seconds.
        taskMgr.doMethodLater(5, self.__displayGolfSpotAdvice,
                              self.golfSpotAdviceName)
        #taskMgr.doMethodLater(10, self.__displayMagnetAdvice,
        #                      self.magnetAdviceName)

        # Up in the sky, it's hard to read what people are saying.
        #NametagGlobals.setOnscreenChatForced(1)

        self.arrowVert = 0
        self.arrowHorz = 0
        if self.powerBar:
            self.powerBar.show()

    def __disableControlInterface(self):
        """Disable the control interface."""
        #self.__turnOffMagnet()

        if self.closeButton:
            self.closeButton.destroy()
            self.closeButton = None

        self.__cleanupGolfSpotAdvice()
        #self.__cleanupMagnetAdvice()

        self.ignore('escape')
        self.ignore('control')
        self.ignore('control-up')
        self.ignore('InputState-forward')
        self.ignore('InputState-reverse')
        self.ignore('InputState-turnLeft')
        self.ignore('InputState-turnRight')

        self.arrowVert = 0
        self.arrowHorz = 0

        #NametagGlobals.setOnscreenChatForced(0)

        taskMgr.remove('watchGolfSpotControls')
        if self.powerBar:
            self.powerBar.hide()
        else:
            self.notify.debug('self.powerBar is none')
        #self.__setMoveSound(None)        

    def setupPowerBar(self):
        """Create the power bar for the water golfSpot."""
        self.powerBar = DirectWaitBar(
            pos = (0.0, 0, -0.94),
            relief = DGG.SUNKEN,
            frameSize = (-2.0,2.0,-0.2,0.2),
            borderWidth = (0.02,0.02),
            scale = 0.25,
            range = 100,
            sortOrder = 50,
            frameColor = (0.5,0.5,0.5,0.5),
            barColor =  (1.0,0.0,0.0,1.0),
            text = "",
            text_scale = 0.26,
            text_fg = (1, 1, 1, 1),
            text_align = TextNode.ACenter,
            text_pos = (0,-0.05),
            )
            
        self.power = 0
        self.powerBar['value'] = self.power
        self.powerBar.hide()

    def resetPowerBar(self):
        """Bring the power and power bar to zero."""
        self.power = 0
        self.powerBar['value'] = self.power
        self.powerBar['text'] = ''


    def __displayGolfSpotAdvice(self, task):
        """Display golfSpot advice on the screen."""
        if self.golfSpotAdviceLabel == None:
            self.golfSpotAdviceLabel = DirectLabel(
                text = TTLocalizer.BossbotGolfSpotAdvice,
                text_fg = VBase4(1,1,1,1),
                text_align = TextNode.ACenter,
                relief = None,
                pos = (0, 0, 0.69),
                scale = 0.1)

    def __cleanupGolfSpotAdvice(self):
        """Remove golfSpot advice from the screen."""
        if self.golfSpotAdviceLabel:
            self.golfSpotAdviceLabel.destroy()
            self.golfSpotAdviceLabel = None
        taskMgr.remove(self.golfSpotAdviceName)

    def showExiting(self):
        """Indicate that we've sent an exiting message to AI."""
        if self.closeButton:
            self.closeButton.destroy()
            self.closeButton = DirectLabel(
                relief = None,
                text = TTLocalizer.BossbotGolfSpotLeaving,
                pos = (1.05, 0, -0.88),
                text_pos = (0, 0),
                text_scale = 0.06,
                text_fg = VBase4(1, 1, 1, 1),
                )

        self.__cleanupGolfSpotAdvice()
    
    def __exitGolfSpot(self):
        """Handle the toon clicking on exit button."""

        self.d_requestFree(False)


    def __controlPressed(self):
        """Handle control key being pressed."""
        if self.controlKeyAllowed:
            self.__beginFireBall()
        pass
        #self.__cleanupMagnetAdvice()
        #self.__turnOnMagnet()

    def __controlReleased(self):
        """Handle control key being released."""
        if self.controlKeyAllowed:
            self.__endFireBall()

    def __upArrow(self, pressed):
        """Handle up arrow key being pressed."""
        self.__incrementChangeSeq()
        self.__cleanupGolfSpotAdvice()
        if pressed:
            self.arrowVert = 1
        elif self.arrowVert > 0:
            self.arrowVert = 0

    def __downArrow(self, pressed):
        """Handle down arrow key being pressed."""
        self.__incrementChangeSeq()
        self.__cleanupGolfSpotAdvice()
        if pressed:
            self.arrowVert = -1
        elif self.arrowVert < 0:
            self.arrowVert = 0

    def __rightArrow(self, pressed):
        """Handle right arrow key being pressed."""
        self.__incrementChangeSeq()
        self.__cleanupGolfSpotAdvice()
        if pressed:
            self.arrowHorz = 1
            self.switchToAnimState('GolfRotateLeft')
        elif self.arrowHorz > 0:
            self.arrowHorz = 0
            self.switchToAnimState('GolfPuttLoop')

    def __leftArrow(self, pressed):
        """Handle left arrow key being pressed."""
        self.__incrementChangeSeq()
        self.__cleanupGolfSpotAdvice()
        if pressed:
            self.arrowHorz = -1
            self.switchToAnimState('GolfRotateRight')
        elif self.arrowHorz < 0:
            self.arrowHorz = 0
            self.switchToAnimState('GolfPuttLoop')
        

    def __watchControls(self, task):
        """Check the arrow key press and call move golfSpot if needed."""
        if self.arrowHorz:
            self.__moveGolfSpot(self.arrowHorz)
        else:
            pass
            #self.__setMoveSound(None)
        return Task.cont

    def __moveGolfSpot(self, xd):
        """Rotate the golfSpot by the given xdelta."""
        dt = globalClock.getDt()

        h = self.root.getH() - xd * self.rotateSpeed * dt
        h %= 360
        limitH = h
        self.root.setH(limitH)
        #self.__setMoveSound(self.craneMoveSfx)

    def __incrementChangeSeq(self):
        """Increment our change counter."""
        self.changeSeq = (self.changeSeq + 1) & 0xff


    def __beginFireBall(self):
        """Handle player pressing control and starting the power meter."""        
        # The control key was pressed.
        if self.aimStart != None:
            # This is probably just key-repeat.
            return
        if not self.state == 'Controlled':
            return
        if not self.avId == localAvatar.doId:
            return
        time = globalClock.getFrameTime()
        self.aimStart = time
        messenger.send('wakeup')
        taskMgr.add(self.__updateBallPower, self.ballPowerTaskName)
    
    def __endFireBall(self):
        """Handle player releasing control and shooting the ball."""
        # The control key was released.  Fire the ball.        
        if self.aimStart == None:
            return
        if not self.state == 'Controlled':
            return        
        if not self.avId == localAvatar.doId:
            return
        #if not self.power:
        #    return
        taskMgr.remove(self.ballPowerTaskName)
        self.disableControlKey()
        messenger.send('wakeup')
        self.aimStart = None
        power = self.power
        angle = self.root.getH()
        self.notify.debug('incrementing self.__flyBallSequenceNum')
        self.__flyBallSequenceNum = (self.__flyBallSequenceNum +1) % 0xff
        
        self.sendSwingInfo(power, angle, self.__flyBallSequenceNum)
        self.setSwingInfo(power, angle, self.__flyBallSequenceNum)

        self.resetPowerBar()
        pass
        #self.__turnOffMagnet()

    def __updateBallPower(self, task):
        """Change the value of the power meter."""
        if not self.powerBar:
            print("### no power bar!!!")
            return task.done

        newPower =  self.__getBallPower(globalClock.getFrameTime())
        self.power = newPower
        self.powerBar['value'] = newPower
        return task.cont        
        
    def __getBallPower(self, time):
        """Return a value between 0 and 100 to indicate golf power."""
        elapsed = max(time - self.aimStart, 0.0)
        t = elapsed / self.golfPowerSpeed
        t = math.pow(t, self.golfPowerExponent)
        power = int(t * 100) % 200
        if power > 100:
            power = 200 - power
        return power

    def stopPosHprBroadcast(self):
        """Stop the pitcher rotation broadcast task."""
        taskName = self.posHprBroadcastName
        taskMgr.remove(taskName)

    def startPosHprBroadcast(self):
        """Start the golfSpot rotation broadcast task."""
        taskName = self.posHprBroadcastName

        # Broadcast our initial position
        self.b_clearSmoothing()
        self.d_sendGolfSpotPos()

        # remove any old tasks
        taskMgr.remove(taskName)
        taskMgr.doMethodLater(self.__broadcastPeriod,
                              self.__posHprBroadcast, taskName)

    def __posHprBroadcast(self, task):
        """Periodically broadcast the golfSpot rotation."""
        self.d_sendGolfSpotPos()
        taskName = self.posHprBroadcastName
        taskMgr.doMethodLater(self.__broadcastPeriod,
                              self.__posHprBroadcast, taskName)
        return Task.done


    def d_sendGolfSpotPos(self):
        """Send the golfSpot rotation to the other clients."""
        timestamp = globalClockDelta.getFrameNetworkTime()

        self.sendUpdate('setGolfSpotPos', [
        self.changeSeq,  self.root.getH(), timestamp])

    def setGolfSpotPos(self, changeSeq, h, timestamp):
        """Handle another client sending an update on the golfSpot rotation."""
        #assert self.notify.debugStateCall(self)
        self.changeSeq = changeSeq
        if self.smoothStarted:
            now = globalClock.getFrameTime()
            local = globalClockDelta.networkToLocalTime(timestamp, now)

            #self.golfSpotSmoother.setY(y)
            self.golfSpotSmoother.setH(h)
            self.golfSpotSmoother.setTimestamp(local)
            self.golfSpotSmoother.markPosition()
        else:
            #self.crane.setY(y)
            self.root.setH(h)


    ### Handle smoothing of distributed updates.  This is similar to
    ### code in DistributedSmoothNode, but streamlined for our
    ### purposes.

    def b_clearSmoothing(self):
        """Tell us and other clients to clear smoothing."""
        self.d_clearSmoothing()
        self.clearSmoothing()
        
    def d_clearSmoothing(self):
        """Tell other clients to clear smoothing."""
        self.sendUpdate("clearSmoothing", [0])

    def clearSmoothing(self, bogus = None):
        """Invalidate old position reports."""
        # Call this to invalidate all the old position reports
        # (e.g. just before popping to a new position).
        self.golfSpotSmoother.clearPositions(1)

    def doSmoothTask(self, task):
        """
        This function updates the position of the node to its computed
        smoothed position.  This may be overridden by a derived class
        to specialize the behavior.
        """
        self.golfSpotSmoother.computeAndApplySmoothHpr(self.root)

        return Task.cont

    def startSmooth(self):
        """
        This function starts the task that ensures the node is
        positioned correctly every frame.  However, while the task is
        running, you won't be able to lerp the node or directly
        position it.
        """
        if not self.smoothStarted:
            taskName = self.smoothName
            taskMgr.remove(taskName)
            self.reloadPosition()
            taskMgr.add(self.doSmoothTask, taskName)
            self.smoothStarted = 1

    def stopSmooth(self):
        """
        This function stops the task spawned by startSmooth(), and
        allows show code to move the node around directly.
        """
        if self.smoothStarted:
            taskName = self.smoothName
            taskMgr.remove(taskName)
            self.forceToTruePosition()
            self.smoothStarted = 0


    def makeToonReleaseInterval(self, toon):
        """Return an interval of the toon jumping to pitcher position."""
        def getSlideToPos(toon = toon):
            return render.getRelativePoint(toon, Point3(0, -5, 0))
        
        if self.gotHitByBoss:
            grabIval = Sequence(
                Func(self.detachClub),
                name = 'makeToonReleaseInterval-gotHitByBoss'
                )
            if not toon.isEmpty():
                toonIval = Sequence(
                    Func(toon.wrtReparentTo, render),
                    Parallel(
                        ActorInterval(toon, 'slip-backward'),
                        toon.posInterval(0.5, getSlideToPos, fluid = 1)
                        ),
                    name = 'makeToonReleaseInterval-toonIval'
                    )
                    #Func(toon.loop, 'neutral'),
                grabIval.append(toonIval)
                
        else:
            grabIval = Sequence(
                Func(self.detachClub),
                )
            if not toon.isEmpty():
                toonIval = Sequence(
                    Parallel(
                        ActorInterval(toon, 'walk', duration = 1.0, playRate = -1.0),
                        LerpPosInterval(toon, duration = 1.0,
                                           pos = Point3(-10,0,0),
                                           )
                        ),
                    Func(toon.wrtReparentTo, render),
                    #Func(toon.loop, 'neutral'),
                    )
                grabIval.append(toonIval)

        if localAvatar.doId == toon.doId:
            if not self.goingToReward and toon.hp >0:
                grabIval.append( Func(self.goToFinalBattle))
                grabIval.append( Func(self.notify.debug, 'goingToFinalBattlemode'))
                grabIval.append( Func(self.safeBossToFinalBattleMode))
        
        return grabIval   

    def safeBossToFinalBattleMode(self):
        """Call boss.toFinalBattleMode if self.boss is valid."""
        if self.boss:
            self.boss.toFinalBattleMode()

    def goToFinalBattle(self):
        """Go to final battle if we're in crane mode."""
        # This is a bit hacky.  Go back to finalBattle mode, but
        # only if we're still in crane mode.  (We might have been
        # zapped to 'ouch' mode by a hit.)
        if self.cr:
            place = self.cr.playGame.getPlace()
            if place and hasattr(place, 'fsm'):
                curState = place.fsm.getCurrentState().getName()
                if place.fsm.getCurrentState().getName() == 'crane':
                    place.setState('finalBattle')
                else:
                    self.notify.debug('NOT going to final battle, state=%s'% curState)

    def attachClub(self, avId, pointToBall = False):
        """Attach the club to the right hand."""
        club = self.club 
        if club :
            av = base.cr.doId2do.get(avId)
            if av:
                av.useLOD(1000)
                lHand = av.getLeftHands()[0]
                club.setPos(0,0,0)
                club.reparentTo(lHand)
                # we have to account for small toons like the mouse
                netScale = club.getNetTransform().getScale()[1]
                counterActToonScale = lHand.find('**/counteractToonScale')
                if counterActToonScale.isEmpty():                    
                    counterActToonScale = lHand.attachNewNode('counteractToonScale')
                    counterActToonScale.setScale( 1 /netScale)
                    self.notify.debug('creating counterActToonScale for %s' % av.getName())
                club.reparentTo(counterActToonScale)
                club.setX(-0.25 * netScale )                
                if pointToBall:
                    club.lookAt(self.clubLookatSpot)
                # self.notify.debug('after lookat, hpr = %s' % club.getHpr())        

    def detachClub(self):
        """Detach the club and store it someplace safe."""
        if not self.club.isEmpty():
            self.club.reparentTo(self.root)
            self.club.setZ(-20)
            self.club.setScale(1)

    def adjustClub(self):
        """Change the club so that the head is more or less behind the ball."""
        club = self.club
        if club:
            distance = club.getDistance(self.clubLookatSpot)            
            # from maya the club has a length of 2.058, 
            scaleFactor = distance / 2.058
            # self.notify.debug('scaleFactor  = %s' % scaleFactor)
            club.setScale(1, scaleFactor, 1)

    def startAdjustClubTask(self):
        """Start the task to automatically adjust the club so it looks right."""
        taskMgr.add(self.adjustClubTask, self.adjustClubTaskName)

    def stopAdjustClubTask(self):
        """Stop the task to automatically adjust the club so it looks right."""
        taskMgr.remove(self.adjustClubTaskName)

    def adjustClubTask(self, task):
        """Continuously adjust the club so the head is behind the ball."""
        self.attachClub(self.avId, True)
        self.adjustClub()
        return task.cont

    def enableControlKey(self):
        """Allow control key events to come in."""
        self.controlKeyAllowed = True

    def disableControlKey(self):
        """Disable control key events from coming in."""
        self.controlKeyAllowed = False
        
    def sendSwingInfo(self, power, angle, sequenceNum):
        """Tell the other clients we're firing."""
        self.sendUpdate('setSwingInfo', [power, angle, sequenceNum])

    def startBallPlayback(self, power, angle, sequenceNum):
        """Start the ball flying in the air."""
        assert self.notify.debugStateCall(self)
        # duplicate our current ball model
        flyBall = self.ballModel.copyTo(NodePath())
        flyBall.setScale(1.0)

        flyBallBubble = self.getFlyBallBubble().instanceTo(NodePath())
        flyBallBubble.reparentTo(flyBall)

        flyBall.setTag('pieSequence', str(sequenceNum))
        flyBall.setTag('throwerId', str(self.avId))
        
        # First, create a ProjectileInterval to compute the relative
        # velocity.

        t = power / 100.0

        # make the ball travel farther, the longer you press the bar
        t = 1.0 - t

        # Distance ranges from 300 - 100 ft, time ranges from 1.5 - 2 s.
        dist = 300 - 200 * t
        time = 1.5 + 0.5 * t
        proj = ProjectileInterval(
            None, startPos = Point3(0, 0, 0), endPos = Point3(0, dist, 0),
            duration = time,
            )
        relVel = proj.startVel

        def getVelocity(root = self.root, relVel = relVel):
            return render.getRelativeVector(root, relVel)
        fly = Sequence(
            #Func(self.ballModel.hide),
            Func(flyBall.reparentTo, render),
            Func(flyBall.setPosHpr, self.root, 0, 0, 0, 0, 0, 0),
            Func(base.cTrav.addCollider, flyBallBubble, self.flyBallHandler),
            ProjectileInterval(flyBall, startVel = getVelocity, duration =3),
            Func(flyBall.detachNode),
            Func(base.cTrav.removeCollider, flyBallBubble),
            Func(self.notify.debug, "removed collider"),
            Func(self.flyBallFinishedFlying, sequenceNum)
            )
        flyWithSound = Parallel(
            fly,
            SoundInterval(self.hitBallSfx, node=self.root),
            name = 'flyWithSound'
            )
        self.notify.debug('starting flyball track')
        flyWithSound.start()
        self.flyBallTracks[sequenceNum] = flyWithSound
         
        pass

    def setSwingInfo(self, power, angle, sequenceNum):
        """Handle a toon swinging at the golf ball."""
        assert self.notify.debugStateCall(self)
        av = base.cr.doId2do.get(self.avId)
        self.swingInterval = Sequence()
        if av:
            self.stopAdjustClubTask()
            self.swingInterval = Sequence(
                ActorInterval(av, 'swing-putt', startFrame = 0, endFrame = GolfGlobals.BALL_CONTACT_FRAME),
                Func(self.startBallPlayback, power, angle, sequenceNum),
                Func(self.ballModel.hide),
                ActorInterval(av, 'swing-putt', startFrame = GolfGlobals.BALL_CONTACT_FRAME, endFrame = 24),
                Func(self.ballModel.setScale,0.1),
                Func(self.ballModel.show),
                LerpScaleInterval(self.ballModel, 1.0, Point3(1, 1, 1)),          
                Func(self.enableControlKey),
                )
            if av == localAvatar:
                self.swingInterval.append(Func(self.switchToAnimState, 'GolfPuttLoop', True))
        
        self.swingInterval.start()
           
    def getFlyBallBubble(self):
        if self.__flyBallBubble == None:
            bubble = CollisionSphere(0, 0, 0, GolfGlobals.GOLF_BALL_RADIUS)
            node = CollisionNode('flyBallBubble')
            node.addSolid(bubble)
            node.setFromCollideMask(ToontownGlobals.PieBitmask | ToontownGlobals.CameraBitmask | ToontownGlobals.FloorBitmask)
            node.setIntoCollideMask(BitMask32.allOff())
            self.__flyBallBubble = NodePath(node)
            self.flyBallHandler = CollisionHandlerEvent()
            self.flyBallHandler.addInPattern('flyBallHit-%d' % self.index)
            #self.flyBallHandler.addInPattern('flyBallHit-%d--%in')
        return self.__flyBallBubble

    def __flyBallHit(self, entry):
        """Handle the flying golf ball hitting something in the world."""
        #import pdb; pdb.set_trace()
        print(entry)
        pass

    def flyBallFinishedFlying(self, sequence):
        """Handle the flyball sequence finishing."""
        if sequence in self.flyBallTracks:
            del self.flyBallTracks[sequence]

    def __finishFlyBallTrack(self, sequence):
        """Force the flyball sequence to finish prematurely."""
        if sequence in self.flyBallTracks:
            flyBallTrack = self.flyBallTracks[sequence]
            del self.flyBallTracks[sequence]
            flyBallTrack.finish()

    def flyBallFinishedSplatting(self, sequence):
        """Handle the flyball splatt finishing."""
        if sequence in self.splatTracks:
            del self.splatTracks[sequence]

    def __flyBallHit(self, entry):
        """Handle the flyball colliding against something in the world."""
        if not entry.hasSurfacePoint() or not entry.hasInto():
            # Not a collision solid we understand.  Weird.
            return
        if not entry.getInto().isTangible():
            # Just a trigger polygon.  Ignore it.
            return

        sequence = int(entry.getFromNodePath().getNetTag('pieSequence'))
        self.__finishFlyBallTrack(sequence)

        if sequence in self.splatTracks:
            splatTrack = self.splatTracks[sequence]
            del self.splatTracks[sequence]
            splatTrack.finish()

        # The pie hit something solid.  Generate a distributed splat.

        # Check the thing we hit for a pieCode.  If it has one, it
        # gets passed along with the message.  This may mean something
        # different according to context (it may indicate, for
        # instance, the kind of target we hit).
        flyBallCode = 0
        flyBallCodeStr = entry.getIntoNodePath().getNetTag('pieCode')
        if flyBallCodeStr:
            flyBallCode = int(flyBallCodeStr)
        
        pos = entry.getSurfacePoint(render)
        timestamp32 = globalClockDelta.getFrameNetworkTime(bits = 32)
        throwerId=int(entry.getFromNodePath().getNetTag('throwerId'))
        splat = self.getFlyBallSplatInterval(pos[0], pos[1], pos[2], flyBallCode, throwerId)

        splat = Sequence(splat,
                         Func(self.flyBallFinishedSplatting, sequence))
        assert sequence not in self.splatTracks
        self.splatTracks[sequence] = splat
        splat.start()
       
        
        self.notify.debug('doId=%d into=%s flyBallCode=%d, throwerId=%d' %
                          (self.doId, entry.getIntoNodePath(), flyBallCode,throwerId))

        if flyBallCode ==  ToontownGlobals.PieCodeBossCog and \
           self.avId == localAvatar.doId and \
           self.lastHitSequenceNum != self.__flyBallSequenceNum:
            self.lastHitSequenceNum = self.__flyBallSequenceNum
            self.boss.d_ballHitBoss(2)
        elif flyBallCode == ToontownGlobals.PieCodeToon and \
             self.avId == localAvatar.doId and \
             self.lastHitSequenceNum != self.__flyBallSequenceNum:
            self.lastHitSequenceNum = self.__flyBallSequenceNum
            avatarDoId = entry.getIntoNodePath().getNetTag('avatarDoId')
            if avatarDoId == '':
                self.notify.warning("Toon %s has no avatarDoId tag." % (repr(entry.getIntoNodePath())))
                return
            doId = int(avatarDoId)
            if doId != localAvatar.doId:
                # turn this off since food comes out of the belt
                # self.boss.d_hitToon(doId)         
                pass

    def getFlyBallSplatInterval(self, x, y, z, flyBallCode,throwerId):
        """Return an interval showing a flyBall hitting a target in the world."""
        from toontown.toonbase import ToontownBattleGlobals
        from toontown.battle import BattleProps

        splatName = 'dust'
        splat = BattleProps.globalPropPool.getProp(splatName)
        splat.setBillboardPointWorld(2)

        color = ToontownGlobals.PieCodeColors.get(flyBallCode)
        if color:
            splat.setColor(*color)
        if flyBallCode == ToontownGlobals.PieCodeBossCog:
            self.notify.debug('changing color to %s' % self.ballColor)
            splat.setColor(self.ballColor)

        sound = loader.loadSfx('phase_11/audio/sfx/LB_evidence_miss.ogg')
        vol = 1.0
        if flyBallCode == ToontownGlobals.PieCodeBossCog:
            sound = loader.loadSfx('phase_4/audio/sfx/Golf_Hit_Barrier_1.ogg')
        soundIval = SoundInterval(sound, node = splat, volume = vol)

        if flyBallCode == ToontownGlobals.PieCodeBossCog and \
           localAvatar.doId == throwerId:
            vol = 1.0
            soundIval = SoundInterval(sound, node = localAvatar, volume = vol)       

        ival = Parallel(
            Func(splat.reparentTo, render),
            Func(splat.setPos, x, y, z),
            soundIval,
            Sequence(ActorInterval(splat, splatName),
                     Func(splat.detachNode)),
            )
        return ival

    def setGoingToReward(self):
        """Flag that the boss battle is going to the reward state."""
        assert self.notify.debugStateCall(self)
        self.goingToReward = True

    def gotBossZapped(self):
        """Handle the local toon getting hit by a ranged attack."""       
        self.showExiting()   
        self.d_requestFree(True)
